# Build DMG for TidyFlow (D5-3b-1 + D5-3b-2 + D5-3b-3)
# Manual trigger - supports unsigned, signed, and notarized builds
# Next: D5-3c (GitHub Release with tag-based auto-publish)
#
# Signing requires GitHub Secrets:
#   - MACOS_CERT_P12_BASE64: Developer ID Application certificate (p12, base64)
#   - MACOS_CERT_PASSWORD: Password for the p12 file
#   - SIGN_IDENTITY: Full identity string, e.g. "Developer ID Application: Name (TEAMID)"
#
# Notarization requires additional GitHub Secrets:
#   - ASC_API_KEY_ID: App Store Connect API Key ID (e.g. ABCDE12345)
#   - ASC_API_ISSUER_ID: App Store Connect Issuer ID (UUID)
#   - ASC_API_KEY_P8_BASE64: AuthKey_XXXX.p8 file content (base64 encoded)

name: Build Release DMG

on:
  workflow_dispatch:
    inputs:
      skip_core:
        description: 'Skip core rebuild (use cached)'
        required: false
        default: false
        type: boolean
      sign:
        description: 'Sign the app with Developer ID certificate'
        required: false
        default: false
        type: boolean
      notarize:
        description: 'Notarize the signed app (requires sign=true)'
        required: false
        default: false
        type: boolean

env:
  CARGO_TERM_COLOR: always
  KEYCHAIN_NAME: build.keychain
  KEYCHAIN_PASSWORD: ${{ github.run_id }}_${{ github.run_attempt }}

jobs:
  build-dmg:
    name: Build DMG (${{ inputs.notarize && 'notarized' || (inputs.sign && 'signed' || 'unsigned') }})
    runs-on: macos-latest

    steps:
      # Validate: notarize requires sign
      - name: Validate inputs
        if: inputs.notarize && !inputs.sign
        run: |
          echo "::error::Notarization requires signing. Please enable 'sign' when using 'notarize'."
          echo ""
          echo "To notarize an app, it must first be signed with a Developer ID certificate."
          echo "Please re-run the workflow with both 'sign' and 'notarize' checked."
          exit 1

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            core/target
          key: ${{ runner.os }}-cargo-${{ hashFiles('core/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Read version
        id: version
        run: |
          VERSION_INFO=$(./scripts/release/read_version.sh)
          SHORT_VERSION=$(echo "$VERSION_INFO" | cut -d' ' -f1)
          BUILD_NUMBER=$(echo "$VERSION_INFO" | cut -d' ' -f2)
          echo "short=$SHORT_VERSION" >> $GITHUB_OUTPUT
          echo "build=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "full=${SHORT_VERSION}-${BUILD_NUMBER}" >> $GITHUB_OUTPUT
          echo "Version: $SHORT_VERSION ($BUILD_NUMBER)"

      # Certificate import (only when sign=true)
      - name: Import code signing certificate
        if: inputs.sign
        env:
          MACOS_CERT_P12_BASE64: ${{ secrets.MACOS_CERT_P12_BASE64 }}
          MACOS_CERT_PASSWORD: ${{ secrets.MACOS_CERT_PASSWORD }}
        run: |
          # Validate secrets are present
          if [ -z "$MACOS_CERT_P12_BASE64" ]; then
            echo "::error::MACOS_CERT_P12_BASE64 secret is not set"
            exit 1
          fi
          if [ -z "$MACOS_CERT_PASSWORD" ]; then
            echo "::error::MACOS_CERT_PASSWORD secret is not set"
            exit 1
          fi

          # Create temporary keychain
          echo "Creating temporary keychain..."
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Add to keychain search list (prepend to existing)
          security list-keychains -d user -s "$KEYCHAIN_NAME" $(security list-keychains -d user | tr -d '"')

          # Decode and import certificate
          echo "Importing certificate..."
          CERT_FILE=$(mktemp)
          echo "$MACOS_CERT_P12_BASE64" | base64 --decode > "$CERT_FILE"
          security import "$CERT_FILE" \
            -k "$KEYCHAIN_NAME" \
            -P "$MACOS_CERT_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security
          rm -f "$CERT_FILE"

          # Allow codesign to access keychain without prompt
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"

          # Verify certificate is available (don't fail, just log)
          echo "Available signing identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_NAME" | head -5 || true
          echo "Certificate import complete"

      - name: Build DMG
        env:
          SIGN_IDENTITY: ${{ secrets.SIGN_IDENTITY }}
        run: |
          BUILD_ARGS=""
          if [ "${{ inputs.skip_core }}" = "true" ]; then
            BUILD_ARGS="$BUILD_ARGS --skip-core"
          fi
          if [ "${{ inputs.sign }}" = "true" ]; then
            BUILD_ARGS="$BUILD_ARGS --sign"
          fi
          ./scripts/release/build_dmg.sh $BUILD_ARGS

      - name: Verify DMG output
        run: |
          echo "=== DMG Output ==="
          ls -lh dist/*.dmg
          DMG_FILE=$(ls dist/*.dmg | head -1)
          echo "dmg_file=$DMG_FILE" >> $GITHUB_ENV
          echo "dmg_name=$(basename $DMG_FILE)" >> $GITHUB_ENV

      # Signature verification (only when sign=true, before notarization)
      - name: Verify code signature
        if: inputs.sign
        run: |
          echo "=== Mounting DMG ==="
          DMG_FILE=$(ls dist/*.dmg | head -1)
          hdiutil attach "$DMG_FILE" -nobrowse -quiet

          echo ""
          echo "=== Code Signature Verification ==="
          APP_PATH="/Volumes/TidyFlow/TidyFlow.app"
          if codesign --verify --deep --strict --verbose=2 "$APP_PATH" 2>&1; then
            echo "✓ Code signature is valid"
            echo "signature_valid=true" >> $GITHUB_ENV
          else
            echo "✗ Code signature verification failed"
            echo "signature_valid=false" >> $GITHUB_ENV
            hdiutil detach "/Volumes/TidyFlow" -quiet || true
            exit 1
          fi

          echo ""
          echo "=== Unmounting DMG ==="
          hdiutil detach "/Volumes/TidyFlow" -quiet || true

      # Notarization (only when notarize=true, which implies sign=true)
      - name: Setup App Store Connect API key
        if: inputs.notarize
        env:
          ASC_API_KEY_P8_BASE64: ${{ secrets.ASC_API_KEY_P8_BASE64 }}
        run: |
          if [ -z "$ASC_API_KEY_P8_BASE64" ]; then
            echo "::error::ASC_API_KEY_P8_BASE64 secret is not set"
            exit 1
          fi
          echo "$ASC_API_KEY_P8_BASE64" | base64 --decode > AuthKey.p8
          chmod 600 AuthKey.p8
          echo "✓ API key file created"

      - name: Submit for notarization
        if: inputs.notarize
        env:
          ASC_API_KEY_ID: ${{ secrets.ASC_API_KEY_ID }}
          ASC_API_ISSUER_ID: ${{ secrets.ASC_API_ISSUER_ID }}
        run: |
          if [ -z "$ASC_API_KEY_ID" ]; then
            echo "::error::ASC_API_KEY_ID secret is not set"
            exit 1
          fi
          if [ -z "$ASC_API_ISSUER_ID" ]; then
            echo "::error::ASC_API_ISSUER_ID secret is not set"
            exit 1
          fi

          DMG_FILE=$(ls dist/*.dmg | head -1)
          echo "Submitting $DMG_FILE for notarization..."
          echo "This may take several minutes..."

          # Submit and wait for result
          xcrun notarytool submit "$DMG_FILE" \
            --key AuthKey.p8 \
            --key-id "$ASC_API_KEY_ID" \
            --issuer "$ASC_API_ISSUER_ID" \
            --wait \
            --output-format json > dist/notarytool-submit.json 2>&1 || true

          # Check result
          cat dist/notarytool-submit.json

          STATUS=$(cat dist/notarytool-submit.json | grep -o '"status":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
          SUBMISSION_ID=$(cat dist/notarytool-submit.json | grep -o '"id":"[^"]*"' | head -1 | cut -d'"' -f4 || echo "")

          echo "submission_id=$SUBMISSION_ID" >> $GITHUB_ENV

          if [ "$STATUS" = "Accepted" ]; then
            echo "✓ Notarization successful!"
            echo "notarization_status=Accepted" >> $GITHUB_ENV
          else
            echo "✗ Notarization failed with status: $STATUS"
            echo "notarization_status=$STATUS" >> $GITHUB_ENV

            # Try to fetch detailed log
            if [ -n "$SUBMISSION_ID" ]; then
              echo "Fetching notarization log..."
              xcrun notarytool log "$SUBMISSION_ID" \
                --key AuthKey.p8 \
                --key-id "$ASC_API_KEY_ID" \
                --issuer "$ASC_API_ISSUER_ID" \
                dist/notarytool-log.json 2>&1 || true
              if [ -f dist/notarytool-log.json ]; then
                echo "=== Notarization Log ==="
                cat dist/notarytool-log.json
              fi
            fi
            exit 1
          fi

      - name: Staple notarization ticket
        if: inputs.notarize
        run: |
          DMG_FILE=$(ls dist/*.dmg | head -1)
          echo "Stapling notarization ticket to $DMG_FILE..."
          xcrun stapler staple "$DMG_FILE"
          echo "✓ Stapling complete"

      - name: Validate stapled DMG
        if: inputs.notarize
        run: |
          DMG_FILE=$(ls dist/*.dmg | head -1)
          echo "=== Stapler Validation ==="
          xcrun stapler validate "$DMG_FILE"
          echo "✓ Stapler validation passed"

      - name: Verify Gatekeeper assessment
        if: inputs.notarize
        run: |
          echo "=== Mounting DMG ==="
          DMG_FILE=$(ls dist/*.dmg | head -1)
          hdiutil attach "$DMG_FILE" -nobrowse -quiet

          echo ""
          echo "=== Gatekeeper Assessment ==="
          APP_PATH="/Volumes/TidyFlow/TidyFlow.app"
          SPCTL_OUTPUT=$(spctl --assess --type execute --verbose "$APP_PATH" 2>&1) || true
          echo "$SPCTL_OUTPUT"

          if echo "$SPCTL_OUTPUT" | grep -q "accepted"; then
            echo ""
            echo "✓ Gatekeeper assessment PASSED"
            echo "  App is accepted and ready for distribution"
            echo "gatekeeper_passed=true" >> $GITHUB_ENV
          else
            echo ""
            echo "✗ Gatekeeper assessment FAILED"
            echo "gatekeeper_passed=false" >> $GITHUB_ENV
            hdiutil detach "/Volumes/TidyFlow" -quiet || true
            exit 1
          fi

          echo ""
          echo "=== Unmounting DMG ==="
          hdiutil detach "/Volumes/TidyFlow" -quiet || true

      - name: Gatekeeper check (signed only)
        if: inputs.sign && !inputs.notarize
        run: |
          echo "=== Mounting DMG ==="
          DMG_FILE=$(ls dist/*.dmg | head -1)
          hdiutil attach "$DMG_FILE" -nobrowse -quiet

          echo ""
          echo "=== Gatekeeper Assessment ==="
          APP_PATH="/Volumes/TidyFlow/TidyFlow.app"
          # spctl will fail for signed-but-not-notarized apps - this is expected
          if spctl --assess --type execute --verbose "$APP_PATH" 2>&1; then
            echo "✓ Gatekeeper assessment passed"
          else
            echo "⚠ Gatekeeper assessment failed (expected - app is not notarized)"
            echo "  Run with notarize=true for full Gatekeeper approval"
          fi

          echo ""
          echo "=== Unmounting DMG ==="
          hdiutil detach "/Volumes/TidyFlow" -quiet || true

      - name: Cleanup API key
        if: always() && inputs.notarize
        run: |
          rm -f AuthKey.p8
          echo "✓ API key file removed"

      # Cleanup keychain (only when sign=true)
      - name: Cleanup keychain
        if: always() && inputs.sign
        run: |
          security delete-keychain "$KEYCHAIN_NAME" 2>/dev/null || true

      - name: Upload DMG artifact
        uses: actions/upload-artifact@v4
        with:
          name: TidyFlow-${{ steps.version.outputs.full }}${{ inputs.notarize && '-notarized' || (inputs.sign && '-signed' || '') }}-${{ github.sha }}
          path: |
            dist/*.dmg
            dist/notarytool-*.json
          retention-days: 14
          if-no-files-found: error

      - name: Build summary
        run: |
          SIGNED="${{ inputs.sign }}"
          NOTARIZED="${{ inputs.notarize }}"
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ steps.version.outputs.full }} |" >> $GITHUB_STEP_SUMMARY
          echo "| DMG | ${{ env.dmg_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY
          if [ "$SIGNED" = "true" ]; then
            echo "| Signed | ✓ Yes |" >> $GITHUB_STEP_SUMMARY
            echo "| Signature Valid | ${{ env.signature_valid }} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Signed | No |" >> $GITHUB_STEP_SUMMARY
          fi
          if [ "$NOTARIZED" = "true" ]; then
            echo "| Notarized | ✓ Yes |" >> $GITHUB_STEP_SUMMARY
            echo "| Gatekeeper | ${{ env.gatekeeper_passed && '✓ Accepted' || 'Pending' }} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| Notarized | No |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ "$NOTARIZED" = "true" ]; then
            echo "**Status:** Signed and notarized. Ready for distribution!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next:** D5-3c (GitHub Release with tag-based auto-publish)" >> $GITHUB_STEP_SUMMARY
          elif [ "$SIGNED" = "true" ]; then
            echo "**Status:** Signed but not notarized. Gatekeeper will warn on first run." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next:** Run with \`notarize=true\` for full Gatekeeper approval" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Next:** Run with \`sign=true\` for signed build" >> $GITHUB_STEP_SUMMARY
          fi
